$TITLE('"MIMIC" CADE-PN182S1.0 MODULE PUSH BUTTON')
 
PB$MODULE: DO ;
 
	DECLARE FALSE LITERALLY '0' ;
	DECLARE TRUE LITERALLY 'NOT FALSE' ;
	DECLARE INTERRUPT$HANDLER$TASK LITERALLY 'PROCEDURE' ;
	DECLARE BACKGROUND$TASK LITERALLY 'PROCEDURE' ;
	DECLARE FOREVER LITERALLY 'WHILE TRUE' ;
 
	DECLARE DEBOUNCE$MILLISECONDS LITERALLY '10' ;
 
	DECLARE PB$INACTIVE LITERALLY '0' ;
	DECLARE PB$UNDEFINED LITERALLY '-1' ;
	DECLARE LAST$PB$IDENTIFIER LITERALLY '32' ;
 
	DECLARE STRING$LENGTH LITERALLY '20' ;
 
	DECLARE PUSH$BUTTON$BUFFER STRUCTURE(
			MAXIMUM$LENGTH BYTE ,
			ACTUAL$LENGTH BYTE ,
			CHARACTER( STRING$LENGTH ) BYTE ) PUBLIC ;
 
	DECLARE PUSH$BUTTON$DATA$RECEIVED BYTE PUBLIC ;
 
	DECLARE LAST$PUSH$BUTTON BYTE PUBLIC ;
 
	DECLARE PUSH$BUTTON$CONTROL$PORT BYTE PUBLIC  AT ( 3B03H ) ;
	DECLARE PUSH$BUTTON$DATA$PORT BYTE PUBLIC AT ( 3B04H ) ;
	DECLARE PUSH$BUTTON$RESET$PORT BYTE PUBLIC AT ( 3B05H ) ;
 
	DECLARE PBLOCK BYTE EXTERNAL ;
	DECLARE LAST$LAMP$IMAGE (5) BYTE EXTERNAL ;
 
$EJECT
 
	DELAY: PROCEDURE ( MILLISECONDS ) EXTERNAL ;
		DECLARE MILLISECONDS ADDRESS ;
	END DELAY ;
 
	CHARACTER$WRITE: PROCEDURE ( CHARACTER, STRING$PTR ) EXTERNAL ;
		DECLARE CHARACTER BYTE ;
		DECLARE STRING$PTR ADDRESS ;
	END CHARACTER$WRITE ;
 
	HEX$BYTE$WRITE: PROCEDURE ( VALUE, STRING$PTR ) EXTERNAL ;
		DECLARE VALUE BYTE ;
		DECLARE STRING$PTR ADDRESS ;
	END HEX$BYTE$WRITE ;
 
	SEND$OUTPUT$STRING: PROCEDURE ( STRING$PTR ) EXTERNAL ;
		DECLARE STRING$PTR ADDRESS ;
	END SEND$OUTPUT$STRING ;
 
	LAMP$OUTPUT: PROCEDURE ( LAMP$IMAGE$PTR ) EXTERNAL ;
		DECLARE LAMP$IMAGE$PTR ADDRESS ;
	END LAMP$OUTPUT ;
 
	RESTORE$LAMP$IMAGE: PROCEDURE EXTERNAL ;
	END RESTORE$LAMP$IMAGE ;
 
	TARGET$LOAD$MONITOR: PROCEDURE EXTERNAL ;
	END TARGET$LOAD$MONITOR ;
 
$EJECT
 
	PUSH$BUTTON$BUFFER$INITIALIZATION: PROCEDURE PUBLIC ;
 
		DECLARE I BYTE ;
 
		RESET$PB$BUFFER: DO I = 0 TO LAST( PUSH$BUTTON$BUFFER.CHARACTER ) ;
			PUSH$BUTTON$BUFFER.CHARACTER( I ) = 0 ;
		END RESET$PB$BUFFER ;
 
		PUSH$BUTTON$BUFFER.MAXIMUM$LENGTH = LAST( PUSH$BUTTON$BUFFER.CHARACTER ) ;
		PUSH$BUTTON$BUFFER.ACTUAL$LENGTH = 0 ;
		PUSH$BUTTON$DATA$RECEIVED = FALSE ;
 
		RETURN ;
 
	END PUSH$BUTTON$BUFFER$INITIALIZATION ;
 
 
	PB$CLOSED: PROCEDURE ( PB$DATA, BIT$MASK ) BYTE ;
 
		DECLARE PB$DATA BYTE ;
		DECLARE BIT$MASK BYTE ;
 
		DECLARE BIT$STATUS BYTE ;
 
		IF ( ( PB$DATA AND BIT$MASK ) = 0 ) THEN
			BIT$STATUS = FALSE ;
		ELSE
			BIT$STATUS = TRUE ;
 
		RETURN BIT$STATUS ;
 
	END PB$CLOSED ;
 
$EJECT
 
	GET$PUSH$BUTTON: PROCEDURE BYTE ;
 
		DECLARE PB$READ$COMMAND LITERALLY '01000000B' ;
 
		DECLARE PB$IDENTIFIER BYTE ;
 
		DECLARE PB$MAP (64) BYTE DATA (
			01, -1, 03, 04, 05, 08, 07, 06,
			-1, 19, 18, 17, 16, 13, 14, 15,
			-1, -1, 29, 30, 31, 27, 26, 25,
			23, 22, 21, -1, 24, -1, -1, -1,
			12, 11, 10, 09, 32, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1,
			-1, -1, -1, -1, -1, -1, -1, -1 ) ;
 
		DECLARE BIT$MASK (8) BYTE DATA (
			00000001B,
			00000010B,
			00000100B,
			00001000B,
			00010000B,
			00100000B,
			01000000B,
			10000000B ) ;
 
		DECLARE PB$DATA (8) BYTE ;
 
		DECLARE ROW BYTE ;
 
		DECLARE COL BYTE ;
 
		READ$DATA: DO ROW = 0 TO LAST( PB$DATA ) ;
			PUSH$BUTTON$CONTROL$PORT = PB$READ$COMMAND + ROW ;
			PB$DATA( ROW ) = PUSH$BUTTON$DATA$PORT ;
		END READ$DATA ;
 
		PB$IDENTIFIER = PB$INACTIVE ;
		DECODE$PB: DO ROW = 0 TO LAST( PB$DATA ) ;
			BIT$SCAN: DO COL = 0 TO LAST( BIT$MASK ) ;
				IF PB$CLOSED( PB$DATA( ROW ), BIT$MASK( COL ) ) THEN
					IF PB$IDENTIFIER = PB$INACTIVE THEN
						PB$IDENTIFIER = PB$MAP( COL + ( ROW * LENGTH( BIT$MASK ) ) ) ;
					ELSE
						PB$IDENTIFIER = PB$UNDEFINED ;
			END BIT$SCAN ;
		END DECODE$PB ;
 
		RETURN PB$IDENTIFIER ;
 
	END GET$PUSH$BUTTON ;
 
$EJECT
 
	ECHO$PUSH$BUTTON: PROCEDURE ( NEW$PUSH$BUTTON ) ;
 
		DECLARE NEW$PUSH$BUTTON BYTE ;
 
		DECLARE NEW$LAMP$IMAGE (5) BYTE ;
		DECLARE I BYTE ;
 
		COPY$LAST$LAMP$IMAGE: DO I = 0 TO LAST( NEW$LAMP$IMAGE ) ;
			DISABLE ;
				NEW$LAMP$IMAGE(I) = LAST$LAMP$IMAGE(I) ;
			ENABLE ;
		END COPY$LAST$LAMP$IMAGE ;
 
		IF NEW$PUSH$BUTTON <= LAST$PB$IDENTIFIER THEN
 
			LOOKUP$PB: DO CASE NEW$PUSH$BUTTON ;
 
				RETAIN$LAST$LAMP$IMAGE: DO ;
				END RETAIN$LAST$LAMP$IMAGE ;
 
				LAMP$TEST$PB: DO I = 0 TO LAST( NEW$LAMP$IMAGE ) ;
					NEW$LAMP$IMAGE(I) = 11111111B ;
				END LAMP$TEST$PB ;
 
				SYSTEM$FAULT$PB: DO ;
					NEW$LAMP$IMAGE(1) = NEW$LAMP$IMAGE(1) OR 00000001B ;
				END SYSTEM$FAULT$PB ;
 
				LOW$CLE$PB: DO ;
					NEW$LAMP$IMAGE(0) = NEW$LAMP$IMAGE(0) OR 10000000B ;
				END LOW$CLE$PB ;
 
				MEDIUM$CLE$PB: DO ;
					NEW$LAMP$IMAGE(0) = NEW$LAMP$IMAGE(0) OR 00000100B ;
				END MEDIUM$CLE$PB ;
 
				HIGH$CLE$PB: DO ;
					NEW$LAMP$IMAGE(0) = NEW$LAMP$IMAGE(0) OR 00001000B ;
				END HIGH$CLE$PB ;
 
				HP$ROTOR$PB: DO ;
					NEW$LAMP$IMAGE(0) = NEW$LAMP$IMAGE(0) OR 00000001B ;
				END HP$ROTOR$PB ;
 
				RH$ROTOR$PB: DO ;
					NEW$LAMP$IMAGE(0) = NEW$LAMP$IMAGE(0) OR 00010000B ;
				END RH$ROTOR$PB ;
 
				XO$ROTOR$PB: DO ;
					NEW$LAMP$IMAGE(0) = NEW$LAMP$IMAGE(0) OR 01000000B ;
				END XO$ROTOR$PB ;
 
$EJECT
 
				MONITOR$MODE$PB: DO ;
					NEW$LAMP$IMAGE(1) = NEW$LAMP$IMAGE(1) OR 10000000B ;
				END MONITOR$MODE$PB ;
 
				MANUAL$MODE$PB: DO ;
					NEW$LAMP$IMAGE(1) = NEW$LAMP$IMAGE(1) OR 01000000B ;
				END MANUAL$MODE$PB ;
 
				CONTROL$MODE$PB: DO ;
					NEW$LAMP$IMAGE(1) = NEW$LAMP$IMAGE(1) OR 00000010B ;
				END CONTROL$MODE$PB ;
 
				REMOTE$MODE$PB: DO ;
					NEW$LAMP$IMAGE(1) = NEW$LAMP$IMAGE(1) OR 00100000B ;
				END REMOTE$MODE$PB ;
 
				SLOW$RATE$PB: DO ;
					NEW$LAMP$IMAGE(2) = NEW$LAMP$IMAGE(2) OR 00010000B ;
				END SLOW$RATE$PB ;
 
				MEDIUM$RATE$PB: DO ;
					NEW$LAMP$IMAGE(2) = NEW$LAMP$IMAGE(2) OR 00001000B ;
				END MEDIUM$RATE$PB ;
 
				HIGH$RATE$PB: DO ;
					NEW$LAMP$IMAGE(2) = NEW$LAMP$IMAGE(2) OR 00100000B ;
				END HIGH$RATE$PB ;
 
				ZERO$SPEED$PB: DO ;
					NEW$LAMP$IMAGE(2) = NEW$LAMP$IMAGE(2) OR 10000000B ;
				END ZERO$SPEED$PB ;
 
				MEDIUM$SPEED$PB: DO ;
					NEW$LAMP$IMAGE(2) = NEW$LAMP$IMAGE(2) OR 00000001B ;
				END MEDIUM$SPEED$PB ;
 
				HIGH$SPEED$PB: DO ;
					NEW$LAMP$IMAGE(2) = NEW$LAMP$IMAGE(2) OR 00000010B ;
				END HIGH$SPEED$PB ;
 
				SYNC$SPEED$PB: DO ;
					NEW$LAMP$IMAGE(2) = NEW$LAMP$IMAGE(2) OR 01000000B ;
				END SYNC$SPEED$PB ;
 
				OVER$SPEED$PB: DO ;
					NEW$LAMP$IMAGE(2) = NEW$LAMP$IMAGE(2) OR 00000100B ;
				END OVER$SPEED$PB ;
 
$EJECT
 
				HOLD$PB: DO ;
					NEW$LAMP$IMAGE(4) = NEW$LAMP$IMAGE(4) OR 10000000B ;
				END HOLD$PB ;
 
				HOLD$OVERRIDE$PB: DO ;
					NEW$LAMP$IMAGE(4) = NEW$LAMP$IMAGE(4) OR 00000001B ;
				END HOLD$OVERRIDE$PB ;
 
				START$PB: DO ;
					NEW$LAMP$IMAGE(4) = NEW$LAMP$IMAGE(4) OR 01000000B ;
				END START$PB ;
 
				TEST$PB: DO ;
					NEW$LAMP$IMAGE(4) = NEW$LAMP$IMAGE(4) OR 00000010B ;
				END TEST$PB ;
 
				SLOW$XFR$PB: DO ;
					NEW$LAMP$IMAGE(3) = NEW$LAMP$IMAGE(3) OR 00010000B ;
				END SLOW$XFR$PB ;
 
				MEDIUM$XFR$PB: DO ;
					NEW$LAMP$IMAGE(3) = NEW$LAMP$IMAGE(3) OR 00001000B ;
				END MEDIUM$XFR$PB ;
 
				FAST$XFR$PB: DO ;
					NEW$LAMP$IMAGE(3) = NEW$LAMP$IMAGE(3) OR 00100000B ;
				END FAST$XFR$PB ;
 
				OK$TO$TRANSFER$PB: DO ;
					NEW$LAMP$IMAGE(3) = NEW$LAMP$IMAGE(3) OR 00000001B ;
				END OK$TO$TRANSFER$PB ;
 
				FULL$ARC$PB: DO ;
					NEW$LAMP$IMAGE(3) = NEW$LAMP$IMAGE(3) OR 10000000B ;
				END FULL$ARC$PB ;
 
				XFR$HOLD$PB: DO ;
					NEW$LAMP$IMAGE(3) = NEW$LAMP$IMAGE(3) OR 00000010B ;
				END XFR$HOLD$PB ;
 
				PARTIAL$ARC$PB: DO ;
					NEW$LAMP$IMAGE(3) = NEW$LAMP$IMAGE(3) OR 01000000B ;
				END PARTIAL$ARC$PB ;
 
				TARGET$LOAD$PB: DO ;
				END TARGET$LOAD$PB ;
 
			END LOOKUP$PB ;
 
		CALL LAMP$OUTPUT( .NEW$LAMP$IMAGE ) ;
 
		RETURN ;
 
	END ECHO$PUSH$BUTTON ;
 
$EJECT
 
	PUSH$BUTTON$SCANNER$INITIALIZATION: PROCEDURE ;
 
		DECLARE ENCODE$SENSOR$SCAN$MODE$$COMMAND LITERALLY '00000100B' ;
		DECLARE COUNTER$PRESET$COMMAND LITERALLY '00111110B' ;
 
		PUSH$BUTTON$RESET$PORT = 0 ;
 
		PUSH$BUTTON$CONTROL$PORT = ENCODE$SENSOR$SCAN$MODE$COMMAND ;
		PUSH$BUTTON$CONTROL$PORT = COUNTER$PRESET$COMMAND ;
 
		RETURN ;
 
	END PUSH$BUTTON$SCANNER$INITIALIZATION ;
 
 
	PUSH$BUTTON$INITIALIZATION: PROCEDURE PUBLIC ;
 
		CALL PUSH$BUTTON$BUFFER$INITIALIZATION ;
		CALL PUSH$BUTTON$SCANNER$INITIALIZATION ;
 
		LAST$PUSH$BUTTON = GET$PUSH$BUTTON ;
		CALL ECHO$PUSH$BUTTON( LAST$PUSH$BUTTON ) ;
 
		RETURN ;
 
	END PUSH$BUTTON$INITIALIZATION ;
 
$EJECT
 
	PUSH$BUTTON$MONITOR: PROCEDURE PUBLIC ;
 
		DECLARE COUNT BYTE ;
		DECLARE NEW$PUSH$BUTTON BYTE ;
 
		IF PBLOCK THEN
			NEW$PUSH$BUTTON = PB$UNDEFINED ;
		ELSE
			NEW$PUSH$BUTTON = GET$PUSH$BUTTON ;
 
		IF NEW$PUSH$BUTTON = PB$UNDEFINED THEN
			CALL RESTORE$LAMP$IMAGE ;
 
		ELSE IF NEW$PUSH$BUTTON = LAST$PUSH$BUTTON THEN
			CALL ECHO$PUSH$BUTTON( LAST$PUSH$BUTTON ) ;
 
		ELSE
			RECORD$NEW$PUSH$BUTTON: DO ;
				LAST$PUSH$BUTTON = NEW$PUSH$BUTTON ;
 
				IF NEW$PUSH$BUTTON = PB$INACTIVE THEN
					PB$OPERATION$WRAPUP:DO ;
						CALL RESTORE$LAMP$IMAGE ;
						CALL TARGET$LOAD$MONITOR ;
					END PB$OPERATION$WRAPUP ;
 
				ELSE
					UPDATE$LAST$LAMP$IMAGE: DO ;
						CALL ECHO$PUSH$BUTTON( NEW$PUSH$BUTTON ) ;
 
						DISABLE ;
							PUSH$BUTTON$DATA$RECEIVED = TRUE ;
							COUNT = PUSH$BUTTON$BUFFER.ACTUAL$LENGTH ;
							IF COUNT < PUSH$BUTTON$BUFFER.MAXIMUM$LENGTH THEN
								UPDATE$PB$BUFFER: DO ;
									PUSH$BUTTON$BUFFER.CHARACTER( COUNT ) = NEW$PUSH$BUTTON ;
									COUNT = COUNT + 1 ;
									PUSH$BUTTON$BUFFER.ACTUAL$LENGTH = COUNT ;
								END UPDATE$PB$BUFFER ;
 
							ELSE
								OVERWRITE$PB$BUFFER: DO ;
									COUNT = COUNT - 1 ;
									PUSH$BUTTON$BUFFER.CHARACTER( COUNT ) = NEW$PUSH$BUTTON ;
									COUNT = COUNT + 1 ;
									PUSH$BUTTON$BUFFER.ACTUAL$LENGTH = COUNT ;
								END OVERWRITE$PB$BUFFER ;
						ENABLE ;
					END UPDATE$LAST$LAMP$IMAGE ;
			END RECORD$NEW$PUSH$BUTTON ;
		RETURN ;
 
	END PUSH$BUTTON$MONITOR ;
 
$EJECT
 
	PBSCAN: INTERRUPT$HANDLER$TASK PUBLIC ;
 
		CALL DELAY( DEBOUNCE$MILLISECONDS ) ;
 
		CALL PUSH$BUTTON$MONITOR ;
 
		RETURN ;
 
	END PBSCAN ;
 
 
	PUSH$BUTTON$REPORT: PROCEDURE ( PUSH$BUTTON$IDENTIFIER ) ;
 
		DECLARE PUSH$BUTTON$IDENTIFIER BYTE ;
 
		DECLARE OUTPUT$STRING STRUCTURE (
			MAXIMUM$LENGTH BYTE ,
			ACTUAL$LENGTH BYTE ,
			CHARACTER ( STRING$LENGTH ) BYTE ) ;
 
		DECLARE PB$REPORT$TYPE BYTE ;
 
		DECLARE PUSH$BUTTON$VALUE BYTE ;
 
		ENCODE$PUSH$BUTTON$DATA: DO ;
 
			PB$BUFFER$RESET: DO ;
				OUTPUT$STRING.MAXIMUM$LENGTH = LENGTH( OUTPUT$STRING.CHARACTER ) ;
				OUTPUT$STRING.ACTUAL$LENGTH = 0 ;
			END PB$BUFFER$RESET ;
 
			BUILD$PB$REPLY: DO ;
				PB$REPORT$TYPE = 'K' ;
				CALL CHARACTER$WRITE( PB$REPORT$TYPE, .OUTPUT$STRING ) ;
				CALL HEX$BYTE$WRITE( PUSH$BUTTON$IDENTIFIER, .OUTPUT$STRING ) ;
			END BUILD$PB$REPLY ;
 
		END ENCODE$PUSH$BUTTON$DATA ;
 
		CALL SEND$OUTPUT$STRING( .OUTPUT$STRING ) ;
 
		RETURN ;
 
	END PUSH$BUTTON$REPORT ;
 
$EJECT
 
	PUSH$BUTTON$EVENT$HANDLER: PROCEDURE PUBLIC ;
 
		DECLARE TEMP$BUFFER STRUCTURE (
			MAXIMUM$LENGTH BYTE ,
			ACTUAL$LENGTH BYTE ,
			CHARACTER( STRING$LENGTH ) BYTE ) ;
 
		DECLARE I BYTE ;
 
		DECLARE COUNT BYTE ;
		DECLARE SOURCE ADDRESS ;
		DECLARE TARGET ADDRESS ;
 
		DECLARE NEW$PUSH$BUTTON BYTE ;
 
		PB$DATA$COPY: DO ;
			DISABLE ;
				COUNT = PUSH$BUTTON$BUFFER.ACTUAL$LENGTH ;
				SOURCE = .PUSH$BUTTON$BUFFER.CHARACTER ;
				TARGET = .TEMP$BUFFER.CHARACTER ;
				CALL MOVE( COUNT, SOURCE, TARGET ) ;
 
				CALL PUSH$BUTTON$BUFFER$INITIALIZATION ;
			ENABLE ;
		END PB$DATA$COPY ;
 
		NEW$PB$REPORT: DO I = 1 TO COUNT ;
			NEW$PUSH$BUTTON = TEMP$BUFFER.CHARACTER( I - 1 ) ;
			CALL PUSH$BUTTON$REPORT( NEW$PUSH$BUTTON ) ;
		END NEW$PB$REPORT ;
 
		RETURN ;
 
	END PUSH$BUTTON$EVENT$HANDLER ;
 
END PB$MODULE ;
